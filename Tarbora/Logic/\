/*********************************************************************
 * Copyright (C) 2020 Roger Solans Puig
 * Email: roger@solanspuig.cat
 *
 * This file is part of Tarbora. You can obtain a copy at
 * https://github.com/SolansPuig/Tarbora
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *********************************************************************/

#include "ControllerSystem.hpp"
#include "PhysicsSystem.hpp"
#include "EntitySystem.hpp"

namespace Tarbora {
    ComponentPtr controllerFactory(const ActorId &id, const LuaTable &table)
    {
        auto comp = std::shared_ptr<ControllerComponent>(new ControllerComponent(id));
        comp->speed = table.get<float>("speed", 5.f);
        comp->run_speed = table.get<float>("run_speed", 8.f);
        comp->rotation_speed = table.get<float>("rotation_speed", 1.f);
        comp->facing_clamp = table.get<glm::vec3>(
            "facing_clamp", glm::vec3(70.f, 70.f, 70.f));

        comp->enable();
        return comp;
    }

    ComponentPtr sightFactory(const ActorId &id, const LuaTable &table)
    {
        auto comp = std::shared_ptr<SightComponent>(new SightComponent(id));
        comp->eye_position = table.get<glm::vec3>("eye_position", glm::vec3(0.f));
        comp->look_distance = table.get<float>("look_distance", 10.f);

        comp->enable();
        return comp;
    }

    ComponentPtr grabFactory(const ActorId &id, const LuaTable &)
    {
        auto comp = std::shared_ptr<GrabComponent>(new GrabComponent(id));
        //  TODO: Entity types allowed to grab

        comp->enable();
        return comp;
    }

    ControllerSystem::ControllerSystem(World *world) :
        System(world)
    {
        components_->registerFactory(
            "controller", FCTBIND(&ControllerSystem::controllerFactory));
        components_->registerfactory(
            "sight", FCTBIND(&ControllerSystem::sightFactory));
        components_->registerfactory(
            "grab", FCTBIND(&ControllerSystem::grabFactory));
       
        subscribe("set_movement", MSGBIND(&ControllerSystem::setMovement));
        subscribe("set_rotation", MSGBIND(&ControllerSystem::setRotation));
        subscribe("set_facing", MSGBIND(&ControllerSystem::setFacing));
        subscribe("grab", MSGBIND(&ControllerSystem::grabObject));
        subscribe("release", MSGBIND(&ControllerSystem::releaseObject));
        subscribe("grab_distance", MSGBIND(&ControllerSystem::grabDistance));
    }

    void ControllerSystem::setMovement(const MessageSubject &, const MessageBody &body)
    {
        Message::ApplyPhysics m(body);
        ActorId id = m.getId();

        auto controller = components_->getComponent<ControllerComponent>(id);

        if (controller && controller->enabled())
        {
            // Set movement
            controller->movement = controller->speed * m.getDirection();
            bool walking_old = controller->walking;
            controller->walking = glm::length(controller->movement) != 0.f;

            // Send an event if the state changes
            if (controller->walking != walking_old)
            {
                triggerLocal("move_event", Message::Event(
                                 controller->owner,
                                 controller->walking ? "walk" : "stop",
                             ));
            }
        }
    }

    void ControllerSystem::setRotation(const MessageSubject &, const MessageBody &body)
    {
        Message::ApplyPhysics m(body);
        ActorId id = m.getId();

        auto controller = components->getComponent<ControllerComponent>(id);

        if (controller && controller->enabled())
        {
            // Set movement
            controller->rotation = controller->rotation_speed * m.getDirection();
        }
    }

    void ControllerSystem::setFacing(const MessageSubject &, const MessageBody &body)
    {
        Message::ApplyPhysics m(body);
        ActorId id = m.getId();

        auto sight = components->getComponent<SightComponent>(id);
        auto controller = components->getComponent<ControllerComponent>(id);

        if (controller && controller->enabled())
        {
            controller->facing = m.getDirection();
            glm::clamp(controller->facing, controller->facing_clamp);

            if (sight && sight->enabled())
            {
                glm::vec3 facing = glm::radians(controller->facing);
                sight->look_direction =
                    glm::quat(glm::vec3(facing.x, 0.f, -facing.y)) *
                    glm::quat(glm::vec3(0.f, 0.f, 1.f));
            }
        }
    }

    void ControllerSystem::grabObject(const MessageSubject &, const MessageBody &body)
    {
        Message::Actor m(body);
        ActorId id = m.getId();

        auto sight = components->getComponent<SightComponent>(id);
        auto grab = components->getComponent<GrabComponent>(id);

        if (grab && sight && grab->enabled() && sight->enabled())
        {
            grab->target = sight->target;
            grab->distance = sight->target_distance;
            grab->position = sight->target_position;
        }
    }

    void ControllerSystem::releaseObject(const MessageSubject &, const MessageBody &body)
    {
        Message::Actor m(body);
        ActorId id = m.getId();

        auto sight = components->getComponent<SightComponent>(id);
        auto grab = components->getComponent<GrabComponent>(id);

        if (grab && sight && grab->enabled() && sight->enabled())
        {
            grab->target = "";
        }
    }

    void ControllerSystem::grabDistance(const MessageSubject &, const MessageBody &body)
    {
        Message::LookAt m(body);
        ActorId id = m.getId();

        auto grab = components->getComponent<GrabComponent>(id);

        if (grab && grab->enabled())
        {
            grab->distance = std::max(1.f, grab->distance + m.getDistance());
        }
    }

    void ControllerSystem::update(float delta_time)
    {
        auto comps = components_->getComponents<ControllerComponent>();
        for (auto controller : comps)
        {
            const ActorId &id = controller->owner;

            auto transform = components_->getComponent<TransformComponent>(id);
            auto physics = components_->getComponent<PhysicsComponent>(id);
            auto sight = component_->getComponent<SightComponent>(id);

            if (controller->enabled() && physics && physics->enabled() && transform)
            {
                // Check if the entity is on the ground or falling
                auto ray = physics->body.raycast(
                    glm::vec3(0.f),                      // From the center
                    glm::quat(glm::vec3(0.f, 1.f, 0.f)), // Point down
                    physics->height_/2.f                 // To the feet
                );

                if (ray.target)
                {
                    if (!controller->on_ground)
                    {
                        // TODO: Just hit the ground... Do something!
                    }

                    physics->body.setDamping(0.999999f, 0.f);
                    controller->on_ground = true;
                }
                else
                {
                    physics->body.setDamping(0.f, 0.f);
                    controller->on_ground = false;
                }

                // Check where the entity is looking at
                if (sight && sight->enabled())
                {
                    auto ray = physics->body.raycast(
                        sight->eyes_position,
                        sight->look_direction,
                        sight->look_distance
                    );

                    ActorId target = "";
                    if (ray)
                    {
                        target = ray.hit_id;
                        sight->target_distance = ray.distance;
                        sight->target_position = ray.position;
                    }
                    if (sight->target != target)
                    {
                        sight->target = target;
                        trigger("look_at", Message::LookAt(
                                    id,
                                    sight->target,
                                    sight->target_distance,
                                    sight->target_position
                                ));
                    }
                }

                trigger("move_node", Message::MoveNode(
                            id,
                            "head",
                            glm::quat(
                                glm::vec3(controller->facing.x, 0.f, controller->facing.y)
                            )
                        ));

                trigger("move_node", Message::MoveNode(
                            id,
                            "neck",
                            glm::quat(glm::vec3(0.f, controller->facing.y, 0.f))
                        ));

                /*
                // Move the grabbed object (if any)
                if (grab && grab->enabled())
                {
                    // Has a target but no constraint is created, so create it
                    if (grab->target && !grab->constraint)
                    {
                        auto target = components->getComponent<PhysicsComponent>(
                            grab->target
                        );
                        grab->constraint_ = PhysicsEngine::setP2PConstraint(
                            target,
                            grab->position,
                            300.f,                   // Constraint's impulse clamp
                            0.5f,                    // Constraint's tau
                            glm::vec3(0.f, 0.f, 0.f) // Target angular factor
                        );
                    }

                    // Has a target and a constriant, so move it
                    if (grab->target && grab->constraint && sight && sight->enabled())
                    {
                        glm::vec3 dir = transform->orientation * sight->look_direction;
                        glm::vec3 pos = dir * grab->distance + transform->position;

                        PhysicsEngine::setPointB(grab->constraint, pos);
                    }

                    // Has a constraint but no longer a target, so destroy it
                    if (!grab->target && grab->constraint)
                    {
                        grab->constraint = nullptr;
                        // TODO: Continue that
                    }
                }
                */
                //  Update the physics component
                physics->body.setVelocity(controller->movement);
                physics->body.setRotation(controller->rotation);
            }
        }
    }
}
